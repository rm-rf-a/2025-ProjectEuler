-------------------------------------------------------------------------
소수를 크기 순으로 나열하면 2, 3, 5, 7, 11, 13, ... 과 같이 됩니다.

이 때 10,001번째의 소수를 구하세요.
-------------------------------------------------------------------------


import math
def primenumber(x):
    for i in range (2, int(math.sqrt(x))+1,1):
        if x % i == 0 :
            return False
    return True
cnt = 0
for i in range(2,10000000,1):
    if  1 == primenumber(i):
        cnt = cnt+1
        if cnt==10001:
            print(i)
            break

여러모로 비효율적인코드
범위도 별로 안크고 시간이 중요한게 아니기 떄문에 그냥 쉽게쉽게 만듦
소수판별은 그냥 만들기귀찮아서 남의코드 가져옴
짝수는 어짜피 소수가 안되니까 cnt=1 로시작해서 for에서 3으로 시작해서 2씩 더해가고 소수판별함수도 3에서 시작해서 2씩더해가면 조금더 빠름
에라토스테네스체로 만들어도되는데 개인적으로 별로안좋아함, 너무 큰 배열을 원해서 큰 소수를 다룰떄는 써먹기 귀찮음


디버깅용으로 프린트넣어봤는데 확실히 출력이 잡아먹는 시간이 큰듯.

요즘 문제나다른거나 이것저것 풀면서 느끼는건데 메모리크기관리만 잘할수있으면 확실히 c나cpp같은 c랭귀지가 속도가 빨라서 좋은듯
아니면 pypy나 다른 빠른속도의 파이썬을 쓰는게 좋은듯

-------------------------------------------------------------------------------------------------
에라토스테네스의 체(the sieve of Eratosthenes)
주어진 자연수 n
까지의 모든 소수를 찾는 고대의 알고리즘이다. 첫 소수인 2부터 시작해서 각 소수의 배수가 되는 합성수를 제거하는 방법을 반복하여 모든 소수를 걸러낸다. 작은 범위에서 모든 소수를 찾아내는 가장 효율적인 방법 중 하나이다.

알고리즘
2부터 n
까지의 모든 자연수의 목록을 만든다: (2, 3, 4, ..., n).
초기 상태에 변수 p
 값으로 최소 소수인 2를 대입한다.
2p
에서 n
까지 모든 p
의 배수를 목록에서 찾아 제거 표시한다: (2p, 3p, 4p, ...; p는 제외).
p
보다 큰 수 중에서 제거 표시가 안 된 가장 작은 수를 찾는다. 그런 수가 없다면 종료하고, 있다면 그 수를 p
에 대입하고 3번부터 다시 반복한다.
알고리즘이 종료할 때, 목록에서 제거 표시가 되지 않고 남아 있는 수들이 n
까지의 모든 소수이다.
에라토스테네스의 체는 소수의 개수를 세는 데도 사용될 수 있다.

위키백과, 에라토스테네스의 체
Wikipedia, Sieve of Eratosthenes
OEIS, A000040 The prime numbers.
MathWorld, Sieve of Eratosthenes
-------------------------------------------------------------------------------------------------
