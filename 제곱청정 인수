Problem 362

1일차
한국 프로젝트 오일러에 푼사람 한명밖에없어서 풀어보면 재밋을듯
뭔가 보일듯말듯하는데 숫자가 말도안되게커서 풀기 힘들어보임

2일차
소인수분해까지 일단 구현함
얘 떄문에 밤에 잠도 못자고 학교에서도 수업안들림;;
생각해낸방법
  i번안)
    - 소인수분해한다.
    - 중복없이 더해낸다.
    ex)  2*2*3*3*3*19 
          3이 3개이니까 [3]*[3]*[3]을 놓고 생각한다
          그다음으로 많은 2를 놓고 [3]*[3]*[3]*2*2, [3]*[3]*[3*2]*2 , [3]*[3*2]*[3*2] 순으로 조합을 만든다.
          그다음을 많은 19를 놓고 재귀함수를 이용해서 같은 방법을 한개씩 밀어넣으면서 더한다.
          (중복이 생기는지 뺴먹는 경우가 있는지 잘 모르겠음)

  ii번안)
    - 소인수분해한다.
    - 소수의 종류와 갯수를 구한다
        - 가장많은 갯수가 최소로 곱해질 수 있는 칸의 갯수
        - 총 소수 갯수가 가장 많은 칸으로 곱하는경우의 갯수
    - 전체경우를 구한뒤에 빼낸다.
    ex)  2*2*3*3*3*19 
        3이 가장 3개로 가장 많으니까
         [] * [] * [] 로 3개가 최소갯수
        총 소인수분해한 갯수가 6개니까
         [] * [] * [] * [] * [] * [] 로 6개가 최대갯수
         3~6칸의 경우를 구하면 된다,
        중복조합공식을 잘 사용하여 3~6칸일 떄 구하고 같은 소수가 한칸에 두개이상들어간 경우를 뺸다 (서순이 달라도 같은조합임에 유의)

  iii번안) 학교에서 떠올렸는데 기억이안난다...
          별로 좋은 방법은 아니였던듯.....



-------------------------------------------------------------------------------------------------------------------
#from sympy.ntheory import factorint

n = 101
arr1 = [1 for i in range(n)]
prime = []
for i in range(2,int(n**0.5+1),1):
    for u in range(2*i,n,i):
        arr1[u]=0
        
for i in range(2,len(arr1),1):
    if arr1[i] == 1:
        prime.append(i)

        

def factorization (x) :
    factorization_list = []
    i=0
    while x>1:
        if x%prime[i]==0:
            factorization_list.append(prime[i])
            x = x//prime[i]
            i=0
        else :
            i=i+1
    return factorization_list

print(factorization(54))
-------------------------------------------------------------------------------------------------------------------
소인수분해함. 이제 생각해보자~~
  
